# -*- coding: utf-8 -*-
"""md_methods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11XLC5CI81AeZCTbsLo0dJJbgW84gSES0
"""

from sympy import *
x,y = symbols('x y')
import numpy as np
import pandas as pd
from scipy.optimize import line_search
import numpy.linalg as ln

import plotly
import plotly.graph_objs as go
import plotly.express as px
from plotly.subplots import make_subplots

def grad_with_constant(variables,function, point = [1,1], la = 0.1 ,eps=10**-5,iter = 500,flag_res = False,flag_w = False):

  '''
  variables: str
    Входная строка с переменными
  function: sympy.function
    Функция
  point: list
    Начальная точка
  la: float
    lambda
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''

  decision = []
  counter = 0
  df = pd.DataFrame(columns=['value', 'result'])
  x,y = symbols(variables)
  f = function.subs({x:x,y:y})
  x_p = np.array(point)
  f_p = float(f.subs({x:x_p[0],y:x_p[1]}))
  f_x = f.diff(x)
  f_y = f.diff(y)
  grad = np.array([float(f_x.subs({x:x_p[0],y:x_p[1]})),float(f_y.subs({x:x_p[0],y:x_p[1]}))])

  fl = True
  while fl==True:
    if counter==iter:
        decision.append(x_p)
        decision.append(f_p)
        decision.append(1)
        fl = False
    if (sum(grad**2)**0.5 < eps):
      fl = False
      decision.append(x_p)
      decision.append(f_p)
      decision.append(0)
    else:
      x_p = x_p - la*grad
      f_p = float(f.subs({x:x_p[0],y:x_p[1]}))
      grad = np.array([float(f_x.subs({x:x_p[0],y:x_p[1]})),float(f_y.subs({x:x_p[0],y:x_p[1]}))])
    counter +=1
    if flag_res == True:
      print(x_p)
      print(f_p)
    if flag_w == True:
      df.loc[len(df)] = [x_p,f_p]

  if len(decision)==0:
    decision.append(2)   
  if flag_w == True:
    return (decision,df)
  else:
    return(decision)

def grad_with_fraction(variables,function, point = [1,1],la_0 =0.1, la = 0.1, delta = 0.1 ,eps=10**-5,iter = 500,flag_res = False,flag_w = False):

  '''
  variables: str
    Входная строка с переменными
  function: sympy.function
    Функция
  point: list
    Начальная точка
  la_0: float
    Начальный коэффициент
  la: float
    lambda
  delta: float
    Коэффициент дробления
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''

  decision = []
  counter = 0
  df = pd.DataFrame(columns=['value', 'result'])
  x,y = symbols(variables)
  f = function.subs({x:x,y:y})
  x_p = np.array(point)
  f_p = float(f.subs({x:x_p[0],y:x_p[1]}))
  f_x = f.diff(x)
  f_y = f.diff(y)
  grad_p = np.array([float(f_x.subs({x:x_p[0],y:x_p[1]})),float(f_y.subs({x:x_p[0],y:x_p[1]}))])

  fl = True
  while fl==True:
    if counter==iter:
        decision.append(x_p)
        decision.append(f_p)
        decision.append(1)
        fl = False
    t = x_p - la*grad_p
    f_t = float(f.subs({x:t[0],y:t[1]}))
    while not f_t - f_p <= la * delta * sum(grad_p**2):
      la = la*la_0
      t = x_p - la*grad_p
      f_t = float(f.subs({x:t[0],y:t[1]}))
    
    x_p = t
    f_p = f_t
    grad_p = np.array([float(f_x.subs({x:x_p[0],y:x_p[1]})),float(f_y.subs({x:x_p[0],y:x_p[1]}))])

    if (sum(grad_p**2)**0.5 < eps):
      fl = False
      decision.append(x_p)
      decision.append(f_p)
      decision.append(0)

    counter +=1
    if flag_res == True:
      print(x_p)
      print(f_p)
    if flag_w == True:
      df.loc[len(df)] = [x_p,f_p]

  if len(decision)==0:
    decision.append(2)   
  if flag_w == True:
    return (decision,df)
  else:
    return(decision)

def brent(function, x_res = [-1000,1000] ,eps=10**-5,iter = 500,flag_res = False,flag_w = False):

  '''
  function: sympy.function
    Функция
  x_res: list
    Ограничение на x
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''
  
  decision = []
  counter = 0
  df = pd.DataFrame(columns=['value', 'result'])
  x = Symbol('t')
  f = function.subs({x:x})
  a = x_res[0]
  b = x_res[1]
  tao = (3-5**0.5)/2
  rem = 0
  xl = xm = xs = a + tao*(b-a)
  fxl = fxm = fxs = float(f.subs({x:xs}))
  fl = True
  while fl==True:
    if counter==iter:
        decision.append((a+c)/2)
        decision.append(float(f.subs({x:((a+c)/2)})))
        decision.append(1)
        fl = False
    m = (a+b)/2
    t = eps*abs(xs) + 10**-9

    if abs(xs - m) > 2*t - (b-a)/2:
      p = q = pr_rem = 0
      if abs(rem) > t:
        p = ((xs - xl)**2 * (fxs - fxm) - (xs - xm)**2 * (fxs - fxl))
        q = 2 * ((xs - xl) * (fxs - fxm) - (xs - xm) * (fxs - fxl))

        if q > 0:
          p = -p
        else:
          q = -q
        pr_rem = rem

      if abs(p) < 0.5 * abs(q*pr_rem) and a*q < xs*q + p < b*q:
        rem = p/q
        x_new = xs + rem
        name_step = 'par'

        if x_new - a< 2*t or b - x_new < 2*t:
          if xs < m:
            rem = t
          else:
            rem = -t
      else:
        name_step = 'gold'
        if xs < m:
          rem = (b - xs)*tao
        else:
          rem = (a - xs)*tao
      
      if abs(rem) > t:
        x_new = xs + rem
      elif rem > 0:
        x_new = xs + t
      else:
        x_new = xs - t

      f_new = float(f.subs({x:x_new}))

      if f_new <= fxs:
        if x_new < xs:
          b = xs
        else:
          a = xs
        
        xl = xm
        fxl = fxm

        xm = xs
        fxm = fxs

        xs = x_new
        fxs = f_new

      else:
        if x_new < xs:
          a = x_new
        else:
          b = x_new

        if f_new <= fxm:
          xl = xm
          fxl = fxm

          xm = x_new
          fxm = f_new

        elif f_new <=fxl:
          xl = x_new
          fxl = f_new
    else:
      fl = False
      decision.append(xs)
      decision.append(float(f.subs({x:xs})))
      decision.append(0)      

    counter +=1
    if flag_res == True:
      print(xs)
      print(float(f.subs({x:xs})))
    if flag_w == True:
      df.loc[len(df)] = [xs, float(f.subs({x:xs}))]

  if len(decision)==0:
    decision.append(2)   
  if flag_w == True:
    return (decision,df)
  else:
    return(decision)

def grad_with_optimal(variables,function, point = [1,1],eps=10**-5,iter = 500,flag_res = False,flag_w = False):

  '''
  variables: str
    Входная строка с переменными
  function: sympy.function
    Функция
  point: list
    Начальная точка
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''
  decision = []
  counter = 0
  t = Symbol('t')
  df = pd.DataFrame(columns=['value', 'result'])
  x,y = symbols(variables)
  f = function.subs({x:x,y:y})
  x_p = np.array(point)
  f_p = float(f.subs({x:x_p[0],y:x_p[1]}))
  f_x = f.diff(x)
  f_y = f.diff(y)
  grad_p = np.array([float(f_x.subs({x:x_p[0],y:x_p[1]})),float(f_y.subs({x:x_p[0],y:x_p[1]}))])

  fl = True
  while fl==True:
    if counter==iter:
        decision.append(x_p)
        decision.append(f_p)
        decision.append(1)
        fl = False
    f_gamma = (f.subs({x:(x_p[0] - t*grad_p[0]),y:(x_p[1] - t*grad_p[1])}))    
    gamma = brent(f_gamma)[1]
    x_p = x_p - gamma*grad_p
    grad_p = np.array([float(f_x.subs({x:x_p[0],y:x_p[1]})),float(f_y.subs({x:x_p[0],y:x_p[1]}))])

    if (sum(grad_p**2)**0.5 < eps):
      fl = False
      decision.append(x_p)
      decision.append(f_p)
      decision.append(0)

    counter +=1
    if flag_res == True:
      print(x_p)
      print(f_p)
    if flag_w == True:
      df.loc[len(df)] = [x_p,f_p]

  if len(decision)==0:
    decision.append(2)   
  if flag_w == True:
    return (decision,df)
  else:
    return(decision)

def vizualize_constant(variables,function, point = [1,1], la = 0.1 ,eps=10**-5,iter = 500,flag_res = False,flag_w = False):
  '''
  variables: str
    Входная строка с переменными
  function: sympy.function
    Функция
  point: list
    Начальная точка
  la: float
    lambda
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''
  x,y=symbols(variables)

  f = function.subs({x:x,y:y})

  Points = grad_with_constant(variables = variables, function = function,point = point, la=la,eps = eps,iter = iter, flag_res = False, flag_w = flag_w )

  x_point = Points[0][0]
  y_point = Points[0][1]
  z_point = Points[1]

  x_ = np.round(np.arange(x_point - 10,x_point + 10, 0.1),2)
  y_ = np.round(np.arange(y_point - 10,y_point + 10, 0.1),2)
  z_ = []

  X, Y = np.meshgrid(x_, y_)
  for j in range(len(y_)):
    ax  = []
    for i in range(len(x_)):
      ax.append(float(function.subs({x:x_[i],y:y_[j]})))
    z_.append(ax)

  Z = np.array(z_)

  fig = go.Figure()
  fig.add_trace(go.Surface(x=X,y=Y,z=Z,colorscale='Viridis'))
  fig.add_trace(go.Scatter3d(x=[x_point],y=[y_point],z=[z_point],mode='markers')) 
  fig.update_layout(scene = dict(xaxis_title='X, у.е.',yaxis_title='Y, у.е.',zaxis_title='Z, у.е.'),title_text='F(x,y)= '+str(function),height=600)
  fig.show()

def vizualize_fraction(variables,function, point = [1,1],la_0 = 0.1, la = 0.1, delta = 0.1 ,eps=10**-5,iter = 500,flag_res = False,flag_w = False): 
  
  '''
  variables: str
    Входная строка с переменными
  function: sympy.function
    Функция
  point: list
    Начальная точка
  la_0: float
    Начальный коэффициент
  la: float
    lambda
  delta: float
    Коэффициент дробления
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''
  x,y=symbols(variables)

  f = function.subs({x:x,y:y})

  Points = grad_with_fraction(variables = variables, function = function,point = point,la_0 = la_0, la=la,delta = delta, eps = eps,iter = iter, flag_res = False, flag_w = flag_w )

  x_point = Points[0][0]
  y_point = Points[0][1]
  z_point = Points[1]

  x_ = np.round(np.arange(x_point - 10,x_point + 10, 0.1),2)
  y_ = np.round(np.arange(y_point - 10,y_point + 10, 0.1),2)
  z_ = []

  X, Y = np.meshgrid(x_, y_)
  for j in range(len(y_)):
    ax  = []
    for i in range(len(x_)):
      ax.append(float(function.subs({x:x_[i],y:y_[j]})))
    z_.append(ax)

  Z = np.array(z_)

  fig = go.Figure()
  fig.add_trace(go.Surface(x=X,y=Y,z=Z,colorscale='Viridis'))
  fig.add_trace(go.Scatter3d(x=[x_point],y=[y_point],z=[z_point],mode='markers')) 
  fig.update_layout(scene = dict(xaxis_title='X, у.е.',yaxis_title='Y, у.е.',zaxis_title='Z, у.е.'),title_text='F(x,y)= '+str(function),height=600)
  fig.show()

def vizualize_optimal(variables,function, point = [1,1],eps=10**-5,iter = 500,flag_res = False,flag_w = False):

  '''
  variables: str
    Входная строка с переменными
  function: sympy.function
    Функция
  point: list
    Начальная точка
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''
  x,y=symbols(variables)

  f = function.subs({x:x,y:y})

  Points = grad_with_optimal(variables = variables, function = function,point = point, eps = eps,iter = iter, flag_res = False, flag_w = flag_w )

  x_point = Points[0][0]
  y_point = Points[0][1]
  z_point = Points[1]

  x_ = np.round(np.arange(x_point - 10,x_point + 10, 0.1),2)
  y_ = np.round(np.arange(y_point - 10,y_point + 10, 0.1),2)
  z_ = []

  X, Y = np.meshgrid(x_, y_)
  for j in range(len(y_)):
    ax  = []
    for i in range(len(x_)):
      ax.append(float(function.subs({x:x_[i],y:y_[j]})))
    z_.append(ax)

  Z = np.array(z_)

  fig = go.Figure()
  fig.add_trace(go.Surface(x=X,y=Y,z=Z,colorscale='Viridis'))
  fig.add_trace(go.Scatter3d(x=[x_point],y=[y_point],z=[z_point],mode='markers')) 
  fig.update_layout(scene = dict(xaxis_title='X, у.е.',yaxis_title='Y, у.е.',zaxis_title='Z, у.е.'),title_text='F(x,y)= '+str(function),height=600)
  fig.show()





