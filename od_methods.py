# -*- coding: utf-8 -*-
"""od_methods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aWe_8FArEbsY09TdQSPILBx1cQqUTO6T
"""

from sympy import *
x = Symbol('x')
import numpy as np
import pandas as pd
from scipy.optimize import line_search
import numpy.linalg as ln

import plotly
import plotly.graph_objs as go
import plotly.express as px
from plotly.subplots import make_subplots

def golden_ration(function, x_res = [-1000,1000] ,eps=10**-5,iter = 500,flag_res = False,flag_w = False):

  '''
  function: sympy.function
    Функция
  x_res: list
    Ограничение на x
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''

  decision = []
  counter = 0
  df = pd.DataFrame(columns=['value', 'result'])
  x = Symbol('x')
  f = function.subs({x:x})
  a = x_res[0]
  b = x_res[1]
  tao = (1 + 5**0.5) / 2

  fl = True
  while fl==True:
    x1 = b - (b - a)/tao
    x2 = a + (b - a)/tao
    f1 = float(f.subs({x:x1}))
    f2 = float(f.subs({x:x2}))
    if counter==iter:
        decision.append((a+b)/2)
        decision.append(float(f.subs({x:((a+b)/2)})))
        decision.append(1)
        fl = False
    if f1 > f2:
      a = x1
    else:
      b = x2
    if (abs(a - b) < eps):
      fl = False
      decision.append((b + a)/2)
      decision.append(float(f.subs({x:((b + a)/2)})))
      decision.append(0)
    counter +=1
    if flag_res == True:
      print((b + a)/2)
      print(float(f.subs({x:((b + a)/2)})))
    if flag_w == True:
      df.loc[len(df)] = [(b + a)/2,float(f.subs({x:((b + a)/2)}))]

  if len(decision)==0:
    decision.append(2)   
  if flag_w == True:
    return (decision,df)
  else:
    return(decision)

def parabols(function, x_res = [-1000,1000] ,eps=10**-5,iter = 500,flag_res = False,flag_w = False):

  '''
  function: sympy.function
    Функция
  x_res: list
    Ограничение на x
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''
  
  decision = []
  counter = 0
  df = pd.DataFrame(columns=['value', 'result'])
  x = Symbol('x')
  f = function.subs({x:x})
  x1 = x_res[0]
  x2 = x_res[1]
  x3 = (x1+x2)/2
  f1 = float(f.subs({x:x1}))
  f2 = float(f.subs({x:x2}))
  f3 = float(f.subs({x:x3}))

  fl = True
  while fl==True:
    if counter==iter:
        decision.append(x3)
        decision.append(float(f.subs({x:x3})))
        decision.append(1)
        fl = False
    p = (x3 - x1)**2 * (f3 - f2) - (x3 - x2)**2 * (f3 - f1)
    q = 2*((x3 - x1) * (f3 - f2) - (x3 - x2)*(f3 - f1))

    if q!=0 and p!=0:
      x_new = x3 - p/q

      f_new = float(f.subs({x:x_new}))

      if f_new < f3:
        x1, f1 = x2, f2
        x2, f2 = x3, f3
        x3, f3 = x_new, f_new

      elif f_new < f2:
        x1, f1 = x2, f2
        x2, f2 = x_new, f_new      

      elif f_new < f1:
        x1, f1 = x_new, f_new    
      
      if abs(x2 - x3) < eps and abs(f2 - f3) < eps:
        fl = False
        decision.append(x3)
        decision.append(float(f.subs({x:x3})))
        decision.append(0)

    counter +=1
    if flag_res == True:
      print(x3)
      print(float(f.subs({x:x3})))
    if flag_w == True:
      df.loc[len(df)] = [x3, float(f.subs({x:x3}))]

  if len(decision)==0:
    decision.append(2)   
  if flag_w == True:
    return (decision,df)
  else:
    return(decision)

def brent(function, x_res = [-1000,1000] ,eps=10**-5,iter = 500,flag_res = False,flag_w = False):

  '''
  function: sympy.function
    Функция
  x_res: list
    Ограничение на x
  eps: float
    Eplison
  iter: int
    Количество итераций
  flag_res: boolean
    Необходим ли вывод результатов
  flag_w: boolnean
    Необходима ли запись результатов

  Result: list
    Список координат точек
  '''
  
  decision = []
  counter = 0
  df = pd.DataFrame(columns=['value', 'result'])
  x = Symbol('x')
  f = function.subs({x:x})
  a = x_res[0]
  b = x_res[1]
  tao = (3-5**0.5)/2
  rem = 0
  xl = xm = xs = a + tao*(b-a)
  fxl = fxm = fxs = float(f.subs({x:xs}))
  fl = True
  while fl==True:
    if counter==iter:
        decision.append((a+c)/2)
        decision.append(float(f.subs({x:((a+c)/2)})))
        decision.append(1)
        fl = False
    m = (a+b)/2
    t = eps*abs(xs) + 10**-9

    if abs(xs - m) > 2*t - (b-a)/2:
      p = q = pr_rem = 0
      if abs(rem) > t:
        p = ((xs - xl)**2 * (fxs - fxm) - (xs - xm)**2 * (fxs - fxl))
        q = 2 * ((xs - xl) * (fxs - fxm) - (xs - xm) * (fxs - fxl))

        if q > 0:
          p = -p
        else:
          q = -q
        pr_rem = rem

      if abs(p) < 0.5 * abs(q*pr_rem) and a*q < xs*q + p < b*q:
        rem = p/q
        x_new = xs + rem
        name_step = 'par'

        if x_new - a< 2*t or b - x_new < 2*t:
          if xs < m:
            rem = t
          else:
            rem = -t
      else:
        name_step = 'gold'
        if xs < m:
          rem = (b - xs)*tao
        else:
          rem = (a - xs)*tao
      
      if abs(rem) > t:
        x_new = xs + rem
      elif rem > 0:
        x_new = xs + t
      else:
        x_new = xs - t

      f_new = float(f.subs({x:x_new}))

      if f_new <= fxs:
        if x_new < xs:
          b = xs
        else:
          a = xs
        
        xl = xm
        fxl = fxm

        xm = xs
        fxm = fxs

        xs = x_new
        fxs = f_new

      else:
        if x_new < xs:
          a = x_new
        else:
          b = x_new

        if f_new <= fxm:
          xl = xm
          fxl = fxm

          xm = x_new
          fxm = f_new

        elif f_new <=fxl:
          xl = x_new
          fxl = f_new
    else:
      fl = False
      decision.append(xs)
      decision.append(float(f.subs({x:xs})))
      decision.append(0)      

    counter +=1
    if flag_res == True:
      print(xs)
      print(float(f.subs({x:xs})))
    if flag_w == True:
      df.loc[len(df)] = [xs, float(f.subs({x:xs}))]

  if len(decision)==0:
    decision.append(2)   
  if flag_w == True:
    return (decision,df)
  else:
    return(decision)



def vizualize(function, x_res = [-1000,1000],type_opt ='golden_ration'):

  '''
  function: sympy.function
    Функция
  x_res: list
    Ограничение на x
  type: str
    Метод оптимизации

  fig: graph
    график
  '''
   
  x=symbols('x')

  f = function.subs({x:x})

  x_ = np.round(np.arange(x_res[0],x_res[1], 0.1),2)

  y_ = []

  for i in range(len(x_)):
    y_.append(float(function.subs({x:x_[i]})))

  if type_opt == 'golden_ration':
    Points = golden_ration(function = function ,x_res=x_res)
  if type_opt == 'parabols':
    Points = parabols(function = function ,x_res=x_res)
  if type_opt == 'brent':
    Points = brent(function = function ,x_res=x_res)

  x_points = [Points[0]]
  y_points = [Points[1]]

  fig = go.Figure()
  fig.add_trace(go.Scatter(x=x_,y=y_,name = str(function)))
  fig.add_trace(go.Scatter(x=x_points,y=y_points,mode='markers',name = 'Min')) 
  fig.update_layout(scene = dict(xaxis_title='X, у.е.',yaxis_title='Y, у.е.'),title_text='F(x,y)= '+str(function),height=600)
  fig.show()

def user_input():
  '''
  Пользовательский ввод
  '''


  print('Введите функцию в формате:')
  print('x**2')
  f_1 = sympify(input())

  print('Добавить ограничение на х?')
  print('Yes/No')
  answer_1 = input()
  if answer_1 == 'Yes':
    print('Введите ограничение в формате:')
    print('-1')
    print('1')
    x_res_1 = []
    x_res_1.append(int(input()))
    x_res_1.append(int(input()))
  else:
    x_res_1 = [-1000,1000]   
  print('Введите метод оптимизации в формате:')
  print('golden_ration')
  print('Доступные методы: golden_ration, parabols, brent')
  type_opt_1 = input()

  print('Добавить Epsilon?')
  print('Yes/No')
  answer_3 = input()
  if answer_3 == 'Yes':
    print('Введите Epsilon в формате:')
    print('10**-5')
    eps_1 = sympify(input())
  else:
    eps_1 = 10**-5

  print('Добавить вывод промежуточных результатов?')
  print('Yes/No')
  answer_4 = input()
  if answer_4 == 'Yes':
    flag_res_1 = True
  else:
    flag_res_1 = False

  print('Добавить запись промежуточных результатов?')
  print('Yes/No')
  answer_5 = input()
  if answer_5 == 'Yes':
    flag_w_1 = True
  else:
    flag_w_1 = False

  if type_opt_1 == 'golden_ration':
    result = golden_ration(f_1,x_res_1,eps_1,flag_res_1,flag_w_1)
    for i in result:
      print(i)
    grafic = vizualize(f_1,x_res_1,type_opt_1)
    print(grafic)
  elif type_opt_1 == 'parabols':
    result = parabols(f_1,x_res_1,eps_1,flag_res_1,flag_w_1)
    for i in result:
      print(i)
    grafic = vizualize(f_1,x_res_1,type_opt_1)
    print(grafic)
  elif type_opt_1 == 'brent':
    result = brent(f_1,x_res_1,eps_1,flag_res_1,flag_w_1)
    for i in result:
      print(i)
    grafic = vizualize(f_1,x_res_1,type_opt_1)
    print(grafic)



def BFGS(function, x_res = [-1000,1000] ,c1 = 10**-4, c2 = 10**-9, eps=10**-8,iter = 500,flag_res = False,flag_w = False):

  decision = []
  counter = 0
  df = pd.DataFrame(columns=['value', 'result'])

  x = Symbol('x')
  f = function.subs({x:x})

  def f_x(x_r):
    return  np.array([float(f.subs({x:x_r[0]})),float(f.subs({x:x_r[1]}))])

  def gradient(x_r):
    return np.array([float(f.diff(x).subs({x:x_r[0]})), float(f.diff(x).subs({x:x_r[1]}))])

  #x_k = np.array(x_res).reshape(-1, 1).astype(float)
  #h_k = np.eye(len(x_k)) * eps ** 0.5
  #grad_f_k = gradient(x_res).reshape(-1, 1)
  #f_k = f_x(x_res)

  counter = 0
  gfk = gradient(x_res)
  Hk = np.eye(len(x_k), dtype=int)
  xk = x_res
  fl = True
  while fl==True:
    if counter==iter:
        decision.append((a+c)/2)
        decision.append(f.subs({x:((a+c)/2)}))
        decision.append(1)
        fl = False

    pk = -np.dot(Hk, gfk)


    if sum(grad_f_k ** 2) ** 0.5 < eps:
      fl = False
      decision.append(x_k.reshape(-1))
      decision.append(f_k)
      decision.append(0)   

    p_k = -h_k @ grad_f_k

    alpha_k = line_search(f_x, gradient, xk, pk)[0]
    
    xkp1 = xk + alpha_k * pk
    sk = xkp1 - xk
    xk = xkp1
    
    gfkp1 = fprime(xkp1)
    yk = gfkp1 - gfk
    gfk = gfkp1
    
    k += 1
    
    ro = 1.0 / (np.dot(yk, sk))
    A1 = I - ro * sk[:, np.newaxis] * yk[np.newaxis, :]
    A2 = I - ro * yk[:, np.newaxis] * sk[np.newaxis, :]
    Hk = np.dot(A1, np.dot(Hk, A2)) + (ro * sk[:, np.newaxis] *
                                            sk[np.newaxis, :])


    counter +=1
    if flag_res == True:
      print(x_k.reshape(-1))
      print(f_k)
    if flag_w == True:
      df.loc[len(df)] = [x_k.reshape(-1), f_k]

  if len(decision)==0:
    decision.append(2)   
  if flag_w == True:
    return (decision,df)
  else:
    return(decision)

def BFGS(function, x_res = [-1000,1000] ,c1 = 10**-4, c2 = 10**-9, eps=10**-8,iter = 500,flag_res = False,flag_w = False):

  decision = []
  counter = 0
  df = pd.DataFrame(columns=['value', 'result'])

  x = Symbol('x')
  f = function.subs({x:x})

  def f_x(x_r):
    return  np.array([float(f.subs({x:x_r[0]}))])

  def gradient(x_r):
    return np.array([float(f.diff(x).subs({x:x_r[0]}))])

  x_k = np.array(x_res[0]).reshape(-1, 1).astype(float)
  h_k = np.eye(len(x_k)) * eps ** 0.5
  grad_f_k = gradient(x_res).reshape(-1, 1)
  f_k = f_x(x_res)

  fl = True
  while fl==True:
    if counter==iter:
        decision.append(x_k.reshape(-1))
        decision.append(f_k)
        decision.append(1)
        fl = False

    if sum(grad_f_k ** 2) ** 0.5 < eps:
      fl = False
      decision.append(x_k.reshape(-1))
      decision.append(f_k)
      decision.append(0)   

    p_k = -h_k @ grad_f_k

    alpha_k = line_search(lambda x: f_x(x),lambda x: gradient(x).reshape(1, -1),x_k, p_k,c1=c1, c2=c2, maxiter=iter * 10)[0]

    if alpha_k is None:
        alpha_k = min(eps * 10, 0.01)

    x_k_plus1 = x_k + alpha_k * p_k
    grad_f_k_plus1 = gradient(x_k_plus1)
    s_k = x_k_plus1 - x_k
    y_k = grad_f_k_plus1 - grad_f_k

    ro = 1 / (y_k.T @ s_k)
    i = np.eye(h_k.shape[0])

    h_k = (i - ro * s_k @ y_k.T) @ h_k @ (i - ro * s_k @ y_k.T) + ro * s_k @ s_k.T

    grad_f_k = grad_f_k_plus1
    x_k = x_k_plus1
    f_k = f_x(x_k)

    counter +=1
    if flag_res == True:
      print(x_k.reshape(-1))
      print(f_k)
    if flag_w == True:
      df.loc[len(df)] = [x_k.reshape(-1), f_k]

  if len(decision)==0:
    decision.append(2)   
  if flag_w == True:
    return (decision,df)
  else:
    return(decision)

np.array([0]).reshape(-1, 1).astype(float)

BFGS(x**2,x_res=[2,7])